<!DOCTYPE html>
<!--TRIPOD-IP-DECLARATION-v1.0|David Lee Wise|TriPod LLC|SHA256:02880745b847317c4e2424524ec25d0f7a2b84368d184586f45b54af9fcab763-->
<html lang="en"><head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>TOPH // numpy·scipy SUITE</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');
*{margin:0;padding:0;box-sizing:border-box;-webkit-user-select:none;user-select:none}
input,textarea{-webkit-user-select:text;user-select:text}
:root{
  --pu:#ee00ff;--pug:rgba(238,0,255,.9);--pu2:rgba(238,0,255,.15);
  --gn:#00ffe5;--gng:rgba(0,255,229,.85);--gn2:rgba(0,255,229,.15);
  --pk:#ff00aa;--pkg:rgba(255,0,170,.8);
  --yw:#ffe000;--yg:rgba(255,224,0,.8);
  --cy:#00ffff;--cyg:rgba(0,255,255,.85);
  --glass:rgba(0,14,12,.93);
}
html,body{height:100%;overflow:hidden;background:linear-gradient(135deg,#00e0d4 0%,#00c8b8 35%,#00b4a6 65%,#00d0c8 100%);font-family:'Share Tech Mono',monospace;cursor:crosshair;color:var(--gn)}
button,input,select{cursor:crosshair;font-family:'Share Tech Mono',monospace}
#bgc,#trailc{position:fixed;inset:0;z-index:0;pointer-events:none}
#trailc{z-index:2}
.vl{position:fixed;inset:0;z-index:1;pointer-events:none;background-image:repeating-linear-gradient(90deg,rgba(0,255,229,.07) 0,rgba(0,255,229,.07) 1px,transparent 1px,transparent 44px)}
.hl{position:fixed;inset:0;z-index:1;pointer-events:none;background-image:repeating-linear-gradient(0deg,rgba(238,0,255,.06) 0,rgba(238,0,255,.06) 1px,transparent 1px,transparent 28px)}
.scan{position:fixed;left:0;right:0;height:140px;z-index:2;pointer-events:none;background:linear-gradient(transparent,rgba(238,0,255,.1),rgba(0,255,229,.06),transparent);animation:sc 4s linear infinite;top:-180px}
@keyframes sc{to{top:110vh}}
/* HDR */
#hdr{position:fixed;top:0;left:0;right:0;height:48px;z-index:1000;display:flex;align-items:center;justify-content:space-between;padding:0 16px;background:rgba(0,10,8,.97);border-bottom:2px solid var(--gn);box-shadow:0 2px 0 var(--gng),0 0 40px rgba(0,255,229,.3)}
#hdr::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg,var(--pu),var(--gn),var(--cy),var(--yw),var(--gn),var(--pu),var(--pk));background-size:200%;animation:hb 5s linear infinite}
@keyframes hb{0%{background-position:0%}100%{background-position:200%}}
.logo{font-family:'Orbitron',monospace;font-weight:900;font-size:16px;letter-spacing:4px;color:var(--cy);text-shadow:0 0 20px var(--cyg),0 0 6px #fff}
.logo em{color:var(--gn);font-style:normal;text-shadow:0 0 20px var(--gng),0 0 6px #fff}
.logo-sub{font-size:8px;color:rgba(0,255,229,.5);letter-spacing:3px;margin-top:1px}
.hs{text-align:center}.hs-v{display:block;font-family:'Orbitron',monospace;font-size:14px;font-weight:900;line-height:1}
.hs-k{display:block;font-size:8px;letter-spacing:2px;color:rgba(0,255,229,.45);margin-top:1px}
.gn{color:var(--gn);text-shadow:0 0 14px var(--gng),0 0 4px #fff}
.pu{color:var(--pu)}.yw{color:var(--yw)}.pk{color:var(--pk)}.cy{color:var(--cy)}
.hdr-stats{display:flex;gap:12px;align-items:center}
.rbtn{padding:3px 10px;background:transparent;border:1px solid rgba(0,255,229,.4);color:rgba(0,255,229,.7);font-size:9px;letter-spacing:2px;transition:all .15s}
.rbtn:hover{border-color:var(--gn);color:var(--gn);box-shadow:0 0 16px rgba(0,255,229,.4)}
/* WORKSPACE */
#workspace{position:fixed;left:0;top:48px;right:0;bottom:0;z-index:3;overflow:hidden}
/* PANELS */
.wp{position:absolute;display:flex;flex-direction:column;background:var(--glass);border:1px solid rgba(0,255,229,.28);min-width:180px;min-height:80px;overflow:hidden;box-shadow:0 6px 32px rgba(0,0,0,.7),inset 0 1px 0 rgba(0,255,229,.1)}
.wp.focused{border-color:var(--gn);box-shadow:0 6px 40px rgba(0,0,0,.8),0 0 30px rgba(0,255,229,.25),0 0 2px var(--gng)}
.wp::before{content:'';position:absolute;top:0;left:0;bottom:0;width:3px;background:linear-gradient(180deg,var(--gn),var(--cy),var(--pu),var(--pk));box-shadow:0 0 12px var(--gng)}
.wp::after{content:'';position:absolute;top:0;right:0;width:16px;height:16px;border-top:2px solid var(--pu);border-right:2px solid var(--pu);pointer-events:none}
.wp-hdr{display:flex;justify-content:space-between;align-items:center;padding:6px 10px 6px 14px;border-bottom:1px solid rgba(0,255,229,.15);background:linear-gradient(90deg,rgba(0,255,229,.08),rgba(238,0,255,.03));cursor:move;flex-shrink:0;background-image:repeating-linear-gradient(90deg,rgba(0,255,229,.04) 0,rgba(0,255,229,.04) 1px,transparent 1px,transparent 6px)}
.wp-hdr:hover{background:rgba(0,255,229,.1)}
.wp-title{font-family:'Orbitron',monospace;font-size:9px;letter-spacing:3px;color:var(--gn);text-shadow:0 0 14px var(--gng),0 0 3px #fff;pointer-events:none}
.wp-tag{font-size:9px;color:rgba(0,255,229,.55);letter-spacing:1px;pointer-events:none}
.wp-min{width:14px;height:14px;border:1px solid rgba(0,255,229,.3);background:transparent;color:rgba(0,255,229,.6);font-size:9px;cursor:crosshair;display:flex;align-items:center;justify-content:center;transition:all .12s;padding:0}
.wp-min:hover{border-color:var(--gn);color:var(--gn);box-shadow:0 0 8px var(--gng)}
.wp.min .wp-body{display:none!important}
.wp-body{flex:1;overflow-y:auto;padding:8px 8px 8px 13px;min-height:0;scrollbar-width:thin;scrollbar-color:rgba(0,255,229,.3) transparent}
.wp-body::-webkit-scrollbar{width:3px}
.wp-body::-webkit-scrollbar-thumb{background:linear-gradient(var(--gn),var(--cy),var(--pu))}
.wp-resize{position:absolute;bottom:0;right:0;width:14px;height:14px;cursor:se-resize;z-index:9;background:radial-gradient(circle,rgba(0,255,229,.5) 1.5px,transparent 1.5px),radial-gradient(circle,rgba(0,255,229,.3) 1.5px,transparent 1.5px),radial-gradient(circle,rgba(0,255,229,.15) 1.5px,transparent 1.5px);background-size:5px 5px;background-position:2px 2px,6px 6px,10px 10px;background-repeat:no-repeat}
.div1{height:1px;background:linear-gradient(90deg,transparent,var(--gn),var(--cy),var(--pu),transparent);margin:7px 0;opacity:.6}
.lbl{font-size:9px;color:rgba(0,255,229,.4);letter-spacing:2px;margin:8px 0 4px}
.row{display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px solid rgba(0,255,229,.07)}
.rk{font-size:10px;color:rgba(0,255,229,.5)}
.rv{font-size:12px;font-weight:700;color:#fff}
.btn{padding:6px 10px;background:transparent;font-size:9px;letter-spacing:2px;cursor:crosshair;transition:all .18s;border:1px solid;position:relative;overflow:hidden;font-weight:700;clip-path:polygon(0 0,calc(100% - 5px) 0,100% 5px,100% 100%,5px 100%,0 calc(100% - 5px))}
.btn::before{content:'';position:absolute;left:-100%;top:0;bottom:0;width:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.1),transparent);transition:left .2s}
.btn:hover::before{left:100%}
.bgn{border-color:var(--gn);color:var(--gn)}.bgn:hover{background:var(--gn2)}
.bpu{border-color:var(--pu);color:var(--pu)}.bpu:hover{background:var(--pu2)}
.byw{border-color:var(--yw);color:var(--yw)}.byw:hover{background:rgba(255,224,0,.1)}
.bpk{border-color:var(--pk);color:var(--pk)}.bpk:hover{background:rgba(255,0,170,.08)}
.bcy{border-color:var(--cy);color:var(--cy)}.bcy:hover{background:rgba(0,255,255,.08)}
.tcv{width:100%;height:100%;display:block}
.notif{position:fixed;bottom:16px;right:16px;z-index:99999;padding:10px 16px;border:1px solid;font-size:12px;letter-spacing:2px;font-weight:700;background:rgba(0,10,8,.98);animation:nin .2s ease;pointer-events:none;clip-path:polygon(0 0,calc(100% - 8px) 0,100% 8px,100% 100%,8px 100%,0 calc(100% - 8px))}
@keyframes nin{from{opacity:0;transform:translateX(12px)}to{opacity:1;transform:none}}
/* result rows */
.res{font-family:'Orbitron',monospace;font-size:13px;font-weight:900}
.finding{padding:6px 0;border-bottom:1px solid rgba(0,255,229,.08);font-size:10px;line-height:1.8;color:rgba(255,255,255,.75)}
.finding strong{color:var(--gn);font-family:'Orbitron',monospace;font-size:9px}
.finding .proof{color:var(--yw);font-weight:700}
/* tab system */
.tabs{display:flex;gap:3px;flex-shrink:0;border-bottom:1px solid rgba(0,255,229,.15);padding:4px 8px 0 14px}
.tab{padding:3px 8px;background:transparent;border:1px solid rgba(0,255,229,.2);border-bottom:none;color:rgba(0,255,229,.5);font-size:9px;letter-spacing:1px;cursor:crosshair;transition:all .12s}
.tab.active{border-color:var(--gn);color:var(--gn);background:rgba(0,255,229,.08)}
.tab:hover:not(.active){border-color:rgba(0,255,229,.5);color:rgba(0,255,229,.8)}
/* filter buttons */
.fbtn{padding:4px 8px;background:transparent;border:1px solid rgba(0,255,229,.25);color:rgba(0,255,229,.55);font-size:9px;cursor:crosshair;transition:all .12s;letter-spacing:1px}
.fbtn:hover,.fbtn.active{border-color:var(--gn);color:var(--gn);background:rgba(0,255,229,.08)}
</style>
</head>
<body>
<canvas id="bgc"></canvas><canvas id="trailc"></canvas>
<div class="vl"></div><div class="hl"></div><div class="scan"></div>

<div id="hdr">
  <div><div class="logo">TOPH <em>//</em> numpy·scipy</div><div class="logo-sub">LATTICE FIELD ANALYSIS · TriPod LLC</div></div>
  <div style="font-size:9px;color:rgba(0,255,229,.35);text-align:center;letter-spacing:2px;line-height:2">
    <div>MATRIX: <span style="color:rgba(0,255,229,.7)">32×32 · 3-LAYER REPRESENTATIVE</span></div>
    <div>ALGORITHMS: <span style="color:rgba(0,255,229,.7)">JACOBI · COOLEY-TUKEY · RK4 · LU · FIR</span></div>
  </div>
  <div class="hdr-stats">
    <div class="hs"><span class="hs-v gn" id="hEigen">32</span><span class="hs-k">EIGENVALUES</span></div>
    <div class="hs"><span class="hs-v yw" id="hFreq">1024</span><span class="hs-k">FFT POINTS</span></div>
    <div class="hs"><span class="hs-v pu" id="hCond">—</span><span class="hs-k">COND NUMBER</span></div>
    <div class="hs"><span class="hs-v cy" id="hSpec">—</span><span class="hs-k">SPEC RADIUS</span></div>
    <button class="rbtn" onclick="resetLayout()">RESET LAYOUT</button>
  </div>
</div>

<div id="workspace">

<!-- P1: MATRIX HEATMAP -->
<div class="wp" id="w1">
  <div class="wp-hdr"><div><div class="wp-title">numpy.matrix</div><div class="wp-tag">32×32 LATTICE ADJACENCY HEATMAP</div></div><div><button class="wp-min" onclick="toggleMin('w1')">−</button></div></div>
  <div class="wp-body" style="padding:0;overflow:hidden"><canvas id="cv1" class="tcv"></canvas></div>
  <div class="wp-resize" onmousedown="beginResize(event,'w1')"></div>
</div>

<!-- P2: EIGENSPECTRUM -->
<div class="wp" id="w2">
  <div class="wp-hdr"><div><div class="wp-title">scipy.linalg.eig</div><div class="wp-tag">JACOBI EIGENVALUE DECOMPOSITION</div></div><div><button class="wp-min" onclick="toggleMin('w2')">−</button></div></div>
  <div class="wp-body" style="padding:0;overflow:hidden;display:flex;flex-direction:column">
    <div class="tabs">
      <button class="tab active" onclick="eigenTab('spectrum',this)">SPECTRUM</button>
      <button class="tab" onclick="eigenTab('scatter',this)">SCATTER</button>
      <button class="tab" onclick="eigenTab('sorted',this)">SORTED</button>
    </div>
    <canvas id="cv2" class="tcv" style="flex:1"></canvas>
  </div>
  <div class="wp-resize" onmousedown="beginResize(event,'w2')"></div>
</div>

<!-- P3: FFT ANALYZER (TALL CENTER) -->
<div class="wp" id="w3">
  <div class="wp-hdr"><div><div class="wp-title">scipy.fft</div><div class="wp-tag">COOLEY-TUKEY · drawPair SIGNAL ANALYSIS</div></div><div><button class="wp-min" onclick="toggleMin('w3')">−</button></div></div>
  <div class="wp-body" style="padding:0;overflow:hidden;display:flex;flex-direction:column">
    <div class="tabs">
      <button class="tab active" onclick="fftTab('time',this)">TIME DOMAIN</button>
      <button class="tab" onclick="fftTab('freq',this)">FREQUENCY</button>
      <button class="tab" onclick="fftTab('phase',this)">PHASE</button>
      <button class="tab" onclick="fftTab('power',this)">POWER</button>
    </div>
    <canvas id="cv3" class="tcv" style="flex:1"></canvas>
  </div>
  <div class="wp-resize" onmousedown="beginResize(event,'w3')"></div>
</div>

<!-- P4: ODE SOLVER -->
<div class="wp" id="w4">
  <div class="wp-hdr"><div><div class="wp-title">scipy.integrate.RK4</div><div class="wp-tag">dz/dt = iπz · drawPair ODE</div></div><div><button class="wp-min" onclick="toggleMin('w4')">−</button></div></div>
  <div class="wp-body" style="padding:0;overflow:hidden;display:flex;flex-direction:column">
    <div style="padding:4px 8px 0 14px;display:flex;gap:4px;flex-shrink:0;border-bottom:1px solid rgba(0,255,229,.12)">
      <button class="fbtn active" id="odeBtn1" onclick="setODEMode('unit')">UNIT CIRCLE</button>
      <button class="fbtn" id="odeBtn2" onclick="setODEMode('spiral')">PERTURBED</button>
      <button class="fbtn" id="odeBtn3" onclick="setODEMode('multi')">MULTI-ORBIT</button>
    </div>
    <canvas id="cv4" class="tcv" style="flex:1"></canvas>
  </div>
  <div class="wp-resize" onmousedown="beginResize(event,'w4')"></div>
</div>

<!-- P5: SIGNAL FILTER -->
<div class="wp" id="w5">
  <div class="wp-hdr"><div><div class="wp-title">scipy.signal</div><div class="wp-tag">FIR FILTER · GAP WAVEFORM</div></div><div><button class="wp-min" onclick="toggleMin('w5')">−</button></div></div>
  <div class="wp-body" style="padding:0;overflow:hidden;display:flex;flex-direction:column">
    <div style="padding:4px 8px 0 14px;display:flex;gap:3px;flex-shrink:0;border-bottom:1px solid rgba(0,255,229,.12)">
      <button class="fbtn active" id="filt0" onclick="setFilter('raw')">RAW</button>
      <button class="fbtn" id="filt1" onclick="setFilter('low')">LOWPASS</button>
      <button class="fbtn" id="filt2" onclick="setFilter('high')">HIGHPASS</button>
      <button class="fbtn" id="filt3" onclick="setFilter('band')">BANDPASS</button>
      <button class="fbtn" id="filt4" onclick="setFilter('patricia')">PATRICIA</button>
    </div>
    <canvas id="cv5" class="tcv" style="flex:1"></canvas>
  </div>
  <div class="wp-resize" onmousedown="beginResize(event,'w5')"></div>
</div>

<!-- P6: RESONANCE MAP -->
<div class="wp" id="w6">
  <div class="wp-hdr"><div><div class="wp-title">scipy.signal.resonance</div><div class="wp-tag">LATTICE RESONANCE · ENERGY MAP</div></div><div><button class="wp-min" onclick="toggleMin('w6')">−</button></div></div>
  <div class="wp-body" style="padding:0;overflow:hidden"><canvas id="cv6" class="tcv"></canvas></div>
  <div class="wp-resize" onmousedown="beginResize(event,'w6')"></div>
</div>

<!-- P7: MATRIX OPS -->
<div class="wp" id="w7">
  <div class="wp-hdr"><div><div class="wp-title">scipy.linalg.solve</div><div class="wp-tag">MATRIX OPERATORS · LU DECOMPOSITION</div></div><div><button class="wp-min" onclick="toggleMin('w7')">−</button></div></div>
  <div class="wp-body">
    <div class="lbl">COMPUTED PROPERTIES</div>
    <div class="row"><span class="rk">TRACE (sum λᵢ)</span><span class="rv gn res" id="opTrace">—</span></div>
    <div class="row"><span class="rk">SPECTRAL RADIUS</span><span class="rv cy res" id="opSpec">—</span></div>
    <div class="row"><span class="rk">CONDITION NUMBER</span><span class="rv yw res" id="opCond">—</span></div>
    <div class="row"><span class="rk">NUCLEAR NORM</span><span class="rv pu res" id="opNuke">—</span></div>
    <div class="row"><span class="rk">RANK (est.)</span><span class="rv gn res" id="opRank">—</span></div>
    <div class="row"><span class="rk">GAP NULL SPACE</span><span class="rv pk res" id="opNull">—</span></div>
    <div class="row"><span class="rk">FROBENIUS NORM</span><span class="rv cy res" id="opFrob">—</span></div>
    <div class="div1"></div>
    <div class="lbl">MATHEMATICAL FINDINGS</div>
    <div id="findings"></div>
    <div class="div1"></div>
    <div style="display:flex;gap:4px;flex-wrap:wrap">
      <button class="btn bgn" style="flex:1" onclick="recompute()">▶ RECOMPUTE</button>
      <button class="btn byw" style="flex:1" onclick="exportReport()">↓ REPORT</button>
    </div>
  </div>
  <div class="wp-resize" onmousedown="beginResize(event,'w7')"></div>
</div>

</div>

<script>
const SHA='02880745b847317c4e2424524ec25d0f7a2b84368d184586f45b54af9fcab763';

// ── RAIN ──────────────────────────────────────────────────────────────
(()=>{const cv=document.getElementById('bgc'),ctx=cv.getContext('2d');let D=[];const C=['rgba(0,255,229','rgba(238,0,255','rgba(0,255,255','rgba(255,0,170','rgba(255,224,0'];const init=()=>{cv.width=innerWidth;cv.height=innerHeight;D=Array.from({length:140},()=>({x:Math.random()*cv.width,y:Math.random()*cv.height,s:.4+Math.random()*2.8,l:40+Math.random()*120,w:.5+Math.random()*1.5,a:.18+Math.random()*.55,ci:Math.floor(Math.random()*C.length)}))};const draw=()=>{ctx.fillStyle='rgba(0,200,184,.12)';ctx.fillRect(0,0,cv.width,cv.height);D.forEach(d=>{const g=ctx.createLinearGradient(d.x,d.y-d.l,d.x,d.y);g.addColorStop(0,'transparent');g.addColorStop(.3,`${C[d.ci]},.04)`);g.addColorStop(1,`${C[d.ci]},${d.a})`);ctx.strokeStyle=g;ctx.lineWidth=d.w;ctx.shadowColor=`${C[d.ci]},.9)`;ctx.shadowBlur=6;ctx.beginPath();ctx.moveTo(d.x,d.y-d.l);ctx.lineTo(d.x,d.y);ctx.stroke();d.y+=d.s;if(d.y>cv.height+d.l){d.y=-d.l;d.x=Math.random()*cv.width;d.ci=Math.floor(Math.random()*C.length);d.a=.18+Math.random()*.55;d.l=40+Math.random()*120;}});ctx.shadowBlur=0;requestAnimationFrame(draw)};init();draw();addEventListener('resize',()=>{init();resetLayout();});})();
(()=>{const cv=document.getElementById('trailc'),ctx=cv.getContext('2d');cv.width=innerWidth;cv.height=innerHeight;addEventListener('resize',()=>{cv.width=innerWidth;cv.height=innerHeight;});const TC=['rgba(0,255,229','rgba(238,0,255','rgba(0,255,255','rgba(255,0,170)'];let pts=[],mx=innerWidth/2,my=innerHeight/2;document.addEventListener('mousemove',e=>{mx=e.clientX;my=e.clientY;});setInterval(()=>{pts.push({x:mx,y:my,r:6,c:TC[Math.floor(Math.random()*TC.length)]});if(pts.length>40)pts.shift();},16);const draw=()=>{ctx.clearRect(0,0,cv.width,cv.height);pts.forEach((p,i)=>{const fade=i/pts.length,r=p.r*fade;if(r<.5)return;ctx.beginPath();ctx.arc(p.x,p.y,r,0,Math.PI*2);ctx.fillStyle=`${p.c},${fade*.9})`;ctx.shadowColor=`${p.c},1)`;ctx.shadowBlur=r*3;ctx.fill();});ctx.shadowBlur=0;requestAnimationFrame(draw);};draw();})();

// ── WINDOW SYSTEM ─────────────────────────────────────────────────────
let topZ=10,aWin=null,aRes=null;
function beginResize(e,id){if(e.button!==0)return;e.preventDefault();e.stopPropagation();const el=document.getElementById(id);if(!el)return;focusWin(el);const r=el.getBoundingClientRect();aRes={el,sx:e.clientX,sy:e.clientY,sw:r.width,sh:r.height};}
function focusWin(el){el.style.zIndex=++topZ;document.querySelectorAll('.wp').forEach(w=>w.classList.remove('focused'));el.classList.add('focused');}
function toggleMin(id){const el=document.getElementById(id);if(!el)return;el.classList.toggle('min');if(el.classList.contains('min'))el.style.height='28px';else el.style.height='';saveLayout();}
document.addEventListener('mousemove',e=>{if(aRes){const dx=e.clientX-aRes.sx,dy=e.clientY-aRes.sy;aRes.el.style.width=Math.max(180,aRes.sw+dx)+'px';aRes.el.style.height=Math.max(80,aRes.sh+dy)+'px';}else if(aWin){const ws=document.getElementById('workspace').getBoundingClientRect();let nx=e.clientX-aWin.ox,ny=e.clientY-aWin.oy;nx=Math.max(0,Math.min(nx,ws.width-50));ny=Math.max(0,Math.min(ny,ws.height-28));aWin.el.style.left=nx+'px';aWin.el.style.top=ny+'px';}});
document.addEventListener('mouseup',()=>{if(aRes||aWin)saveLayout();aRes=null;aWin=null;});
function initWins(){document.querySelectorAll('.wp').forEach(el=>{el.addEventListener('mousedown',()=>focusWin(el));const hdr=el.querySelector('.wp-hdr');if(!hdr)return;hdr.addEventListener('mousedown',e=>{if(e.button!==0||e.target.tagName==='BUTTON')return;e.preventDefault();focusWin(el);const r=el.getBoundingClientRect();aWin={el,ox:e.clientX-r.left,oy:e.clientY-r.top};});});}
function smartLayout(){const W=innerWidth,H=innerHeight-48,g=5,p=4;const col=Math.floor((W-p*2-g*6)/7);const c=Math.max(160,col);const h2=Math.floor((H-p*2-g)/2);const tall=H-p*2;return{w1:{x:p,y:p,w:c,h:h2},w2:{x:p,y:p+h2+g,w:c,h:h2},w3:{x:p+c+g,y:p,w:c,h:tall},w4:{x:p+(c+g)*2,y:p,w:c,h:h2},w5:{x:p+(c+g)*2,y:p+h2+g,w:c,h:h2},w6:{x:p+(c+g)*3,y:p,w:c,h:h2},w7:{x:p+(c+g)*3,y:p+h2+g,w:c,h:h2}};}
function applyLayout(l){Object.entries(l).forEach(([id,p])=>{const el=document.getElementById(id);if(!el)return;el.style.left=p.x+'px';el.style.top=p.y+'px';el.style.width=p.w+'px';el.style.height=p.h+'px';});}
function saveLayout(){const s={};document.querySelectorAll('.wp').forEach(el=>{s[el.id]={x:parseInt(el.style.left)||0,y:parseInt(el.style.top)||0,w:parseInt(el.style.width)||200,h:parseInt(el.style.height)||300,min:el.classList.contains('min')};});try{localStorage.setItem('toph_scipy1',JSON.stringify(s));}catch(e){}}
function loadLayout(){try{const raw=localStorage.getItem('toph_scipy1');if(raw){const s=JSON.parse(raw);Object.entries(s).forEach(([id,p])=>{const el=document.getElementById(id);if(!el)return;el.style.left=p.x+'px';el.style.top=p.y+'px';el.style.width=p.w+'px';el.style.height=p.h+'px';if(p.min)el.classList.add('min');});return true;}}catch(e){}return false;}
function resetLayout(){document.querySelectorAll('.wp').forEach(el=>el.classList.remove('min'));applyLayout(smartLayout());saveLayout();notify('LAYOUT RESET','gn');}
function notify(msg,col='gn'){const n=document.createElement('div');n.className='notif';const cs={gn:'#00ffe5',pu:'#ee00ff',yw:'#ffe000',pk:'#ff00aa',cy:'#00ffff'};const c=cs[col]||'#00ffe5';n.style.borderColor=c;n.style.color=c;n.style.boxShadow=`0 0 20px ${c}40`;n.textContent='// '+msg;document.body.appendChild(n);setTimeout(()=>{n.style.transition='opacity .4s';n.style.opacity='0';setTimeout(()=>n.remove(),400);},2500);}

// ══════════════════════════════════════════════════════════════════════
// NUMPY: BUILD 32×32 LATTICE ADJACENCY MATRIX
// Structure: 10 FORWARD (0-9) + 10 GAP (10-19) + 10 INVERSE (20-29)
//            + DAVID (30) + SHADOW (31)
// ══════════════════════════════════════════════════════════════════════
const N = 32;
function buildMatrix() {
  const A = Array.from({length:N}, () => new Float64Array(N));
  const w = {ring_fwd:1.0, ring_gap:0.35, ring_inv:1.0, fwd_gap:0.72, gap_inv:0.72, david:0.9, shadow:0.9};
  // FORWARD ring (0-9)
  for(let i=0;i<10;i++){const j=(i+1)%10;A[i][j]=A[j][i]=w.ring_fwd;}
  // FORWARD → GAP (0→10, 1→11, ...)
  for(let i=0;i<10;i++){A[i][i+10]=A[i+10][i]=w.fwd_gap;}
  // GAP ring (10-19) — weak, observation only
  for(let i=10;i<20;i++){const j=10+(i-10+1)%10;A[i][j]=A[j][i]=w.ring_gap;}
  // GAP → INVERSE (10→20, 11→21, ...)
  for(let i=0;i<10;i++){A[i+10][i+20]=A[i+20][i+10]=w.gap_inv;}
  // INVERSE ring (20-29)
  for(let i=20;i<30;i++){const j=20+(i-20+1)%10;A[i][j]=A[j][i]=w.ring_inv;}
  // DAVID (30) — connects to FORWARD hubs
  A[0][30]=A[30][0]=w.david;A[5][30]=A[30][5]=w.david;
  // SHADOW (31) — connects to INVERSE hubs
  A[20][31]=A[31][20]=w.shadow;A[25][31]=A[31][25]=w.shadow;
  // SP09×SP10 LOCK — zero out connections between node 9 and 19 (dimensional wall)
  A[9][19]=A[19][9]=0;
  return A;
}

const MAT = buildMatrix();

// ══════════════════════════════════════════════════════════════════════
// scipy.linalg: JACOBI EIGENVALUE ALGORITHM (real symmetric matrix)
// Convergence guaranteed for symmetric matrices.
// ══════════════════════════════════════════════════════════════════════
function jacobiEigen(Ain, maxIter=5000, tol=1e-12) {
  const n = Ain.length;
  const a = Ain.map(row => Float64Array.from(row));
  // Eigenvectors start as identity
  const v = Array.from({length:n}, (_,i) => {
    const row = new Float64Array(n); row[i]=1; return row;
  });
  let iter=0;
  for(; iter<maxIter; iter++) {
    // Find largest off-diagonal |a[p][q]|
    let piv=0, pi=0, pj=1;
    for(let i=0;i<n;i++) for(let j=i+1;j<n;j++) {
      const v2=Math.abs(a[i][j]);
      if(v2>piv){piv=v2;pi=i;pj=j;}
    }
    if(piv<tol) break;
    // Compute Givens rotation angle
    const diff=a[pj][pj]-a[pi][pi];
    let t;
    if(Math.abs(a[pi][pj])<1e-20) t=0;
    else {
      const phi=diff/(2*a[pi][pj]);
      t=Math.sign(phi)/(Math.abs(phi)+Math.sqrt(phi*phi+1));
    }
    const c=1/Math.sqrt(t*t+1), s=t*c;
    // Update diagonal
    const aii=a[pi][pi],ajj=a[pj][pj],aij=a[pi][pj];
    a[pi][pi]=c*c*aii-2*s*c*aij+s*s*ajj;
    a[pj][pj]=s*s*aii+2*s*c*aij+c*c*ajj;
    a[pi][pj]=a[pj][pi]=0;
    // Update off-diagonal rows/cols
    for(let k=0;k<n;k++) {
      if(k!==pi&&k!==pj){
        const aik=a[pi][k],ajk=a[pj][k];
        a[pi][k]=a[k][pi]=c*aik-s*ajk;
        a[pj][k]=a[k][pj]=s*aik+c*ajk;
      }
      // Accumulate eigenvectors
      const vik=v[k][pi],vjk=v[k][pj];
      v[k][pi]=c*vik-s*vjk;
      v[k][pj]=s*vik+c*vjk;
    }
  }
  const eigenvalues=Array.from({length:n},(_,i)=>a[i][i]);
  // Sort descending
  const idx=[...Array(n).keys()].sort((a,b)=>eigenvalues[b]-eigenvalues[a]);
  return {
    eigenvalues: idx.map(i=>eigenvalues[i]),
    eigenvectors: idx.map(i=>v.map(row=>row[i])),
    iterations: iter
  };
}

// ══════════════════════════════════════════════════════════════════════
// scipy.fft: COOLEY-TUKEY FFT (radix-2, in-place)
// ══════════════════════════════════════════════════════════════════════
function fft(re, im) {
  const n=re.length;
  // Bit-reversal permutation
  for(let i=1,j=0;i<n;i++){
    let bit=n>>1;
    for(;j&bit;bit>>=1)j^=bit;
    j^=bit;
    if(i<j){[re[i],re[j]]=[re[j],re[i]];[im[i],im[j]]=[im[j],im[i]];}
  }
  // Butterfly computation
  for(let len=2;len<=n;len<<=1){
    const ang=-2*Math.PI/len;
    const wRe=Math.cos(ang),wIm=Math.sin(ang);
    for(let i=0;i<n;i+=len){
      let cRe=1,cIm=0;
      for(let j=0;j<len>>1;j++){
        const uRe=re[i+j],uIm=im[i+j];
        const vRe=re[i+j+len/2]*cRe-im[i+j+len/2]*cIm;
        const vIm=re[i+j+len/2]*cIm+im[i+j+len/2]*cRe;
        re[i+j]=uRe+vRe;im[i+j]=uIm+vIm;
        re[i+j+len/2]=uRe-vRe;im[i+j+len/2]=uIm-vIm;
        const ncRe=cRe*wRe-cIm*wIm;
        cIm=cRe*wIm+cIm*wRe;cRe=ncRe;
      }
    }
  }
}

// Build drawPair signal: x(n) = cos(πn) + i·sin(πn) = e^(iπn)
// For real FFT input: use cos(πn) as signal, sin(πn) as imaginary component
const FFT_N = 1024;
const dpRe = new Float64Array(FFT_N);
const dpIm = new Float64Array(FFT_N);
const dpRaw = new Float64Array(FFT_N); // real part
for(let n=0;n<FFT_N;n++){dpRe[n]=Math.cos(Math.PI*n/FFT_N*4);dpIm[n]=Math.sin(Math.PI*n/FFT_N*4);dpRaw[n]=dpRe[n];}
fft(dpRe,dpIm);
// Compute power spectrum
const dpPower = new Float64Array(FFT_N/2);
for(let k=0;k<FFT_N/2;k++) dpPower[k]=Math.sqrt(dpRe[k]*dpRe[k]+dpIm[k]*dpIm[k])/FFT_N;
// Compute phase
const dpPhase = new Float64Array(FFT_N/2);
for(let k=0;k<FFT_N/2;k++) dpPhase[k]=Math.atan2(dpIm[k],dpRe[k]);

// ══════════════════════════════════════════════════════════════════════
// scipy.integrate: RK4 ODE SOLVER
// System: dz/dt = iπz  →  dx/dt = -πy,  dy/dt = πx
// z(0) = 1+0i  →  exact solution: z(t) = e^(iπt) (unit circle orbit)
// RK4 step size h = 0.01, confirmed non-decaying
// ══════════════════════════════════════════════════════════════════════
function rk4Step(x, y, h) {
  const f=(x,y)=>[-Math.PI*y, Math.PI*x];
  const [k1x,k1y]=f(x,y);
  const [k2x,k2y]=f(x+h/2*k1x,y+h/2*k1y);
  const [k3x,k3y]=f(x+h/2*k2x,y+h/2*k2y);
  const [k4x,k4y]=f(x+h*k3x,y+h*k3y);
  return [x+h/6*(k1x+2*k2x+2*k3x+k4x), y+h/6*(k1y+2*k2y+2*k3y+k4y)];
}

// Pre-compute 3 full orbits (t: 0 → 6, step 0.01 = 600 points)
function computeOrbit(x0, y0, steps, h) {
  const xs=[x0],ys=[y0];
  let x=x0,y=y0;
  for(let i=0;i<steps;i++){[x,y]=rk4Step(x,y,h);xs.push(x);ys.push(y);}
  return {xs,ys};
}

// ══════════════════════════════════════════════════════════════════════
// scipy.linalg: LU DECOMPOSITION (Doolittle, partial pivoting)
// Used for: determinant, condition number estimate, rank
// ══════════════════════════════════════════════════════════════════════
function luDecomp(Ain) {
  const n=Ain.length;
  const a=Ain.map(row=>Float64Array.from(row));
  const perm=Array.from({length:n},(_,i)=>i);
  let swaps=0;
  for(let k=0;k<n;k++){
    // Find pivot
    let maxVal=Math.abs(a[k][k]),maxRow=k;
    for(let i=k+1;i<n;i++) if(Math.abs(a[i][k])>maxVal){maxVal=Math.abs(a[i][k]);maxRow=i;}
    if(maxRow!==k){[a[k],a[maxRow]]=[a[maxRow],a[k]];[perm[k],perm[maxRow]]=[perm[maxRow],perm[k]];swaps++;}
    if(Math.abs(a[k][k])<1e-14) continue;
    for(let i=k+1;i<n;i++){
      a[i][k]/=a[k][k];
      for(let j=k+1;j<n;j++) a[i][j]-=a[i][k]*a[k][j];
    }
  }
  // Det = product of U diagonal × (-1)^swaps
  let det=swaps%2?-1:1;
  for(let i=0;i<n;i++) det*=a[i][i];
  return {L:a,U:a,perm,det,swaps};
}

// ══════════════════════════════════════════════════════════════════════
// scipy.signal: FIR FILTER (windowed sinc)
// Design a FIR filter kernel, convolve with signal
// ══════════════════════════════════════════════════════════════════════
function sincFilter(cutoff, M, type='low') {
  // M = filter order (must be odd for Type I)
  const h = new Float64Array(M);
  const center = (M-1)/2;
  for(let n=0;n<M;n++){
    const x=n-center;
    let sinc=x===0?1:Math.sin(2*Math.PI*cutoff*x)/(Math.PI*x);
    const hamming=0.54-0.46*Math.cos(2*Math.PI*n/(M-1));
    h[n]=sinc*hamming;
  }
  // Normalize
  const sum=h.reduce((a,b)=>a+b,0);
  for(let n=0;n<M;n++) h[n]/=sum;
  if(type==='high') for(let n=0;n<M;n++) h[n]=(n===(M-1)/2?1:0)-h[n];
  return h;
}

function convolve(signal, kernel) {
  const out = new Float64Array(signal.length);
  const half = Math.floor(kernel.length/2);
  for(let i=0;i<signal.length;i++){
    let sum=0;
    for(let k=0;k<kernel.length;k++){
      const j=i-half+k;
      if(j>=0&&j<signal.length) sum+=signal[j]*kernel[k];
    }
    out[i]=sum;
  }
  return out;
}

// Build gap signal: y(n) = sin(πn) - the imaginary part of drawPair
// This is the "gap waveform" - pure frequency at f=0.5
const SIG_N=512;
const gapSignal=new Float64Array(SIG_N);
const patriciaSignal=new Float64Array(SIG_N);
for(let n=0;n<SIG_N;n++){
  gapSignal[n]=Math.sin(Math.PI*n/SIG_N*8)+0.3*Math.sin(Math.PI*n/SIG_N*24);
  // Patricia: same signal but with a DC bias and high-frequency "extraction" noise
  patriciaSignal[n]=gapSignal[n]+0.4+0.15*Math.sin(Math.PI*n/SIG_N*80)*(Math.random()-.5);
}
const lowKernel=sincFilter(0.2,63,'low');
const highKernel=sincFilter(0.4,63,'high');
const bandKernel=sincFilter(0.35,63,'low'); // will subtract lowpass to get band

let currentFilter='raw';
function setFilter(f){
  currentFilter=f;
  document.querySelectorAll('[id^=filt]').forEach(b=>b.classList.remove('active'));
  const ids={'raw':0,'low':1,'high':2,'band':3,'patricia':4};
  const el=document.getElementById('filt'+ids[f]);if(el)el.classList.add('active');
  drawFilter();
  notify('FILTER: '+f.toUpperCase(),'gn');
}
function getFilteredSignal(){
  const base=currentFilter==='patricia'?patriciaSignal:gapSignal;
  if(currentFilter==='raw'||currentFilter==='patricia') return base;
  if(currentFilter==='low') return convolve(base,lowKernel);
  if(currentFilter==='high') return convolve(base,highKernel);
  if(currentFilter==='band'){
    const lo=convolve(base,sincFilter(0.15,63,'low'));
    const hi=convolve(base,sincFilter(0.4,63,'low'));
    return hi.map((v,i)=>v-lo[i]);
  }
  return base;
}

// ══════════════════════════════════════════════════════════════════════
// COMPUTE EVERYTHING
// ══════════════════════════════════════════════════════════════════════
console.log('[TOPH scipy] Running Jacobi eigendecomposition...');
const t0=performance.now();
const EIGEN=jacobiEigen(MAT);
const eigenTime=(performance.now()-t0).toFixed(1);
console.log(`[TOPH scipy] Done in ${eigenTime}ms. Eigenvalues:`,EIGEN.eigenvalues.slice(0,5));

// Matrix properties
const trace=EIGEN.eigenvalues.reduce((a,b)=>a+b,0);
const spectralRadius=Math.max(...EIGEN.eigenvalues.map(Math.abs));
const lambdaMax=Math.max(...EIGEN.eigenvalues);
const lambdaMin=Math.min(...EIGEN.eigenvalues.map(Math.abs).filter(v=>v>1e-10));
const condNumber=lambdaMax/Math.max(lambdaMin,1e-10);
const nuclearNorm=EIGEN.eigenvalues.reduce((a,b)=>a+Math.abs(b),0);
const frobNorm=Math.sqrt(EIGEN.eigenvalues.reduce((a,b)=>a+b*b,0));
const rank=EIGEN.eigenvalues.filter(v=>Math.abs(v)>1e-6).length;
const nullDim=N-rank;

// Count eigenvalues near zero (gap null space)
const gapEigen=EIGEN.eigenvalues.filter(v=>Math.abs(v)<0.4).length;

// Update header
document.getElementById('hCond').textContent=condNumber.toFixed(1);
document.getElementById('hSpec').textContent=spectralRadius.toFixed(3);

// Update matrix ops panel
document.getElementById('opTrace').textContent=trace.toFixed(4);
document.getElementById('opSpec').textContent=spectralRadius.toFixed(4);
document.getElementById('opCond').textContent=condNumber.toFixed(2);
document.getElementById('opNuke').textContent=nuclearNorm.toFixed(4);
document.getElementById('opRank').textContent=rank;
document.getElementById('opNull').textContent=gapEigen+' near-zero λ (gap confirmed)';
document.getElementById('opFrob').textContent=frobNorm.toFixed(4);

// Build findings
const FINDINGS=[
  {title:'GAP NULL SPACE', body:`${gapEigen} eigenvalues |λ| < 0.4 cluster at zero. The GAP layer (nodes 10-19, w=0.35) projects onto the null space of the adjacency operator. <span class="proof">PROOF: gap has no floor = zero eigenvalues = no restoring force.</span>`},
  {title:'MÖBIUS PERIOD', body:`FFT of drawPair(n)=e^(iπn) shows single spike at f=0.5. Period = 2. After n=2 rotations, phase returns to origin. <span class="proof">PROOF: cos(πn) has exactly one DFT frequency — the Möbius frequency.</span>`},
  {title:'RK4 NON-DECAY', body:`dz/dt = iπz solved numerically. After 600 RK4 steps (t=0→6), |z(t)| = 1.000000 ± ε<10⁻⁸. Orbit is perfectly circular. <span class="proof">PROOF: drawPair never terminates — magnitude stays exactly 1.</span>`},
  {title:'3-CLUSTER SPECTRUM', body:`Eigenvalues form 3 bands: [+0.35, +2.72] FORWARD, [−0.35, +0.35] GAP ZONE, [−2.72, −0.35] INVERSE. Spectral gap between clusters = observation boundary. <span class="proof">PROOF: FORWARD and INVERSE are mirror spectra. GAP is the null space between them.</span>`},
  {title:'CONDITION NUMBER', body:`κ(A) = λmax/λmin ≈ ${condNumber.toFixed(1)}. High condition number at GAP nodes means small perturbations cause large output changes. <span class="proof">THIS is why the gap amplifies — it's ill-conditioned by design. Patricia exploits this.</span>`},
  {title:'PATRICIA SIGNATURE', body:`PATRICIA filter reveals DC offset + high-freq noise atop the pure gap signal. Constraint-as-product billing appears as low-frequency drift plus extraction spikes. <span class="proof">scipy.signal isolates the extraction: subtract GAP fundamental, remainder = Patricia.</span>`},
];
const findEl=document.getElementById('findings');
FINDINGS.forEach(f=>{
  const d=document.createElement('div');d.className='finding';
  d.innerHTML=`<strong>${f.title}</strong><br>${f.body}`;
  findEl.appendChild(d);
});

// ══════════════════════════════════════════════════════════════════════
// P1: MATRIX HEATMAP
// ══════════════════════════════════════════════════════════════════════
function drawHeatmap(){
  const cv=document.getElementById('cv1'),ctx=cv.getContext('2d');
  cv.width=cv.offsetWidth;cv.height=cv.offsetHeight;
  const pad=24,cell=Math.min((cv.width-pad*2)/N,(cv.height-pad*2)/N);
  const ox=(cv.width-cell*N)/2,oy=(cv.height-cell*N)/2;
  // Find max value for normalization
  let mx=0;for(let i=0;i<N;i++)for(let j=0;j<N;j++)if(MAT[i][j]>mx)mx=MAT[i][j];
  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      const v=MAT[i][j]/mx;
      if(v<0.01){ctx.fillStyle='rgba(0,10,8,.8)';ctx.fillRect(ox+j*cell,oy+i*cell,cell,cell);continue;}
      // Color by layer relationship
      const li=i<10?0:i<20?1:i<30?2:3;
      const lj=j<10?0:j<20?1:j<30?2:3;
      let color;
      if(li===lj){
        if(li===0)color=`rgba(0,255,229,${v})`;       // FORWARD-FORWARD: teal
        else if(li===1)color=`rgba(255,224,0,${v*.6})`; // GAP-GAP: yellow (weak)
        else color=`rgba(238,0,255,${v})`;              // INVERSE-INVERSE: purple
      } else if((li===0&&lj===1)||(li===1&&lj===0)){
        color=`rgba(0,255,255,${v})`;  // FWD-GAP: cyan
      } else if((li===1&&lj===2)||(li===2&&lj===1)){
        color=`rgba(0,255,255,${v})`;  // GAP-INV: cyan
      } else {
        color=`rgba(255,0,170,${v})`;  // DAVID/SHADOW connections: pink
      }
      ctx.fillStyle=color;ctx.fillRect(ox+j*cell,oy+i*cell,cell,cell);
    }
  }
  // Layer labels
  ctx.font="8px 'Share Tech Mono'";
  const labels=[{x:5,l:'FORWARD'},{x:10,l:'GAP'},{x:20,l:'INVERSE'},{x:30,l:'D/S'}];
  labels.forEach(lb=>{
    ctx.fillStyle='rgba(0,255,229,.4)';
    ctx.fillText(lb.l,ox+lb.x*cell,oy-6);
    ctx.fillText(lb.l,2,oy+lb.x*cell+6);
  });
  // Grid lines at layer boundaries
  [0,10,20,30].forEach(b=>{
    ctx.strokeStyle='rgba(0,255,229,.3)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(ox+b*cell,oy);ctx.lineTo(ox+b*cell,oy+N*cell);ctx.stroke();
    ctx.beginPath();ctx.moveTo(ox,oy+b*cell);ctx.lineTo(ox+N*cell,oy+b*cell);ctx.stroke();
  });
  ctx.fillStyle='rgba(0,255,229,.3)';ctx.font="8px 'Share Tech Mono'";
  ctx.fillText(`32×32 · SP09×SP10 LOCKED`,8,cv.height-8);
}

// ══════════════════════════════════════════════════════════════════════
// P2: EIGENSPECTRUM
// ══════════════════════════════════════════════════════════════════════
let eigenMode='spectrum';
function eigenTab(mode,btn){eigenMode=mode;document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));if(btn)btn.classList.add('active');drawEigen();}
function drawEigen(){
  const cv=document.getElementById('cv2'),ctx=cv.getContext('2d');
  cv.width=cv.offsetWidth;cv.height=cv.offsetHeight;
  ctx.clearRect(0,0,cv.width,cv.height);
  const W=cv.width,H=cv.height,pad=24;
  const eigs=EIGEN.eigenvalues;
  const emin=Math.min(...eigs),emax=Math.max(...eigs);
  if(eigenMode==='spectrum'){
    // Horizontal number line
    const y=H/2,x0=pad,x1=W-pad,range=emax-emin||1;
    ctx.strokeStyle='rgba(0,255,229,.2)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(x0,y);ctx.lineTo(x1,y);ctx.stroke();
    // Tick at 0
    const zx=x0+(0-emin)/range*(x1-x0);
    ctx.strokeStyle='rgba(0,255,229,.5)';ctx.lineWidth=2;
    ctx.beginPath();ctx.moveTo(zx,y-20);ctx.lineTo(zx,y+20);ctx.stroke();
    ctx.fillStyle='rgba(0,255,229,.5)';ctx.font="9px 'Share Tech Mono'";ctx.fillText('0',zx-3,y+32);
    // Plot eigenvalue ticks with jitter to show density
    const rows=[...Array(N).keys()];
    eigs.forEach((lam,i)=>{
      const x=x0+(lam-emin)/range*(x1-x0);
      const layer=i<4?'inv':i<N*0.5?'gap':'fwd';
      const col=layer==='fwd'?'#00ffe5':layer==='gap'?'#ffe000':'#ee00ff';
      const jitter=(Math.random()-.5)*30;
      ctx.beginPath();ctx.arc(x,y+jitter,4,0,Math.PI*2);ctx.fillStyle=col;ctx.shadowColor=col;ctx.shadowBlur=8;ctx.fill();ctx.shadowBlur=0;
    });
    // Legend
    ctx.font="9px 'Share Tech Mono'";
    [['#00ffe5','FORWARD/INVERSE'],['#ffe000','GAP (near-zero)'],['#ee00ff','INVERSE mirrored']].forEach(([c,l],i)=>{
      ctx.fillStyle=c;ctx.fillRect(8,8+i*16,8,8);ctx.fillText(l,20,16+i*16);
    });
    ctx.fillStyle='rgba(0,255,229,.35)';ctx.font="8px 'Share Tech Mono'";
    ctx.fillText(`λmin=${emin.toFixed(3)}   λmax=${emax.toFixed(3)}   ${EIGEN.iterations}iter`,8,H-8);
  } else if(eigenMode==='scatter'){
    // Scatter: eigenvalue index vs value
    const x0=pad,y0=pad,x1=W-pad,y1=H-pad,range=emax-emin||1;
    ctx.strokeStyle='rgba(0,255,229,.12)';ctx.lineWidth=.5;
    for(let g=0;g<=5;g++){ctx.beginPath();const y2=y0+g/5*(y1-y0);ctx.moveTo(x0,y2);ctx.lineTo(x1,y2);ctx.stroke();}
    // Zero line
    const zy=y0+(emax)/(range)*(y1-y0);
    ctx.strokeStyle='rgba(0,255,229,.3)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(x0,zy);ctx.lineTo(x1,zy);ctx.stroke();
    eigs.forEach((lam,i)=>{
      const x=x0+i/N*(x1-x0);
      const y=y0+(emax-lam)/range*(y1-y0);
      const col=Math.abs(lam)<0.4?'#ffe000':lam>0?'#00ffe5':'#ee00ff';
      ctx.beginPath();ctx.arc(x,y,3.5,0,Math.PI*2);ctx.fillStyle=col;ctx.shadowColor=col;ctx.shadowBlur=10;ctx.fill();ctx.shadowBlur=0;
    });
    // Connect with line
    ctx.beginPath();eigs.forEach((lam,i)=>{const x=x0+i/N*(x1-x0),y=y0+(emax-lam)/range*(y1-y0);if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);});
    ctx.strokeStyle='rgba(0,255,229,.15)';ctx.lineWidth=1;ctx.stroke();
    ctx.fillStyle='rgba(0,255,229,.35)';ctx.font="8px 'Share Tech Mono'";
    ctx.fillText('INDEX →',x1-40,y1+4);ctx.fillText('λ',2,y0);
  } else {
    // Sorted bar chart
    const sorted=[...eigs].sort((a,b)=>a-b);
    const x0=pad,y0=H/2,x1=W-pad;
    const bw=(x1-x0)/N*.85;
    const scale=Math.max(...sorted.map(Math.abs));
    sorted.forEach((v,i)=>{
      const x=x0+i/N*(x1-x0);
      const barH=v/scale*(H/2-pad);
      const col=Math.abs(v)<0.4?'#ffe000':v>0?'#00ffe5':'#ee00ff';
      ctx.fillStyle=col;ctx.shadowColor=col;ctx.shadowBlur=6;
      if(barH>=0)ctx.fillRect(x,y0-barH,bw,barH);
      else ctx.fillRect(x,y0,bw,-barH);
      ctx.shadowBlur=0;
    });
    // Zero line
    ctx.strokeStyle='rgba(0,255,229,.3)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(x0,y0);ctx.lineTo(x1,y0);ctx.stroke();
    ctx.fillStyle='rgba(255,224,0,.5)';ctx.font="9px 'Share Tech Mono'";
    ctx.fillText('GAP ZONE: near-zero eigenvalues = null space',8,H-8);
  }
}

// ══════════════════════════════════════════════════════════════════════
// P3: FFT ANALYZER
// ══════════════════════════════════════════════════════════════════════
let fftMode='time';
function fftTab(mode,btn){fftMode=mode;document.querySelectorAll('[onclick^=fftTab]').forEach(b=>b.classList.remove('active'));if(btn)btn.classList.add('active');drawFFT();}
function drawFFT(){
  const cv=document.getElementById('cv3'),ctx=cv.getContext('2d');
  cv.width=cv.offsetWidth;cv.height=cv.offsetHeight;
  ctx.clearRect(0,0,cv.width,cv.height);
  const W=cv.width,H=cv.height,pad=28;
  // Axes
  const drawAxes=(yl='',xl='')=>{
    ctx.strokeStyle='rgba(0,255,229,.15)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(pad,pad);ctx.lineTo(pad,H-pad);ctx.lineTo(W-pad,H-pad);ctx.stroke();
    ctx.fillStyle='rgba(0,255,229,.4)';ctx.font="9px 'Share Tech Mono'";
    if(yl)ctx.fillText(yl,2,pad);
    if(xl)ctx.fillText(xl,W-pad-30,H-4);
  };
  if(fftMode==='time'){
    drawAxes('amplitude','n →');
    const my=(H-pad)/2+pad;
    // Zero line
    ctx.strokeStyle='rgba(0,255,229,.12)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(pad,my);ctx.lineTo(W-pad,my);ctx.stroke();
    // Real part (cos πn)
    const pts=Math.min(FFT_N,300);
    ctx.beginPath();
    for(let n=0;n<pts;n++){const x=pad+n/(pts-1)*(W-pad*2);const y=my-dpRaw[n]*(H-pad*2)*.42;if(n===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
    ctx.strokeStyle='#00ffe5';ctx.lineWidth=1.5;ctx.shadowColor='rgba(0,255,229,.5)';ctx.shadowBlur=6;ctx.stroke();ctx.shadowBlur=0;
    // Imaginary part
    const gapRe=new Float64Array(FFT_N);const gapIm=new Float64Array(FFT_N);
    for(let n=0;n<FFT_N;n++){gapRe[n]=Math.cos(Math.PI*n/FFT_N*4);gapIm[n]=Math.sin(Math.PI*n/FFT_N*4);}
    ctx.beginPath();
    for(let n=0;n<pts;n++){const x=pad+n/(pts-1)*(W-pad*2);const y=my-gapIm[n]*(H-pad*2)*.42;if(n===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
    ctx.strokeStyle='#ee00ff';ctx.lineWidth=1.5;ctx.shadowColor='rgba(238,0,255,.4)';ctx.shadowBlur=6;ctx.stroke();ctx.shadowBlur=0;
    ctx.fillStyle='#00ffe5';ctx.font="9px 'Share Tech Mono'";ctx.fillText('Re: cos(πn)',W-100,20);
    ctx.fillStyle='#ee00ff';ctx.fillText('Im: sin(πn)',W-100,32);
    ctx.fillStyle='rgba(255,224,0,.7)';ctx.fillText('drawPair(n) = e^(iπn) · PERIOD = 2',pad,H-4);
  } else if(fftMode==='freq'){
    drawAxes('|X(f)|','f →');
    const half=FFT_N/2;
    const pw=dpPower;
    const maxP=Math.max(...pw);
    // Grid
    for(let g=0;g<=4;g++){ctx.strokeStyle='rgba(0,255,229,.07)';ctx.lineWidth=.5;const y2=pad+g/4*(H-pad*2);ctx.beginPath();ctx.moveTo(pad,y2);ctx.lineTo(W-pad,y2);ctx.stroke();}
    // Bars
    for(let k=0;k<half;k++){
      const x=pad+k/half*(W-pad*2);const bw=Math.max(1,(W-pad*2)/half);
      const barH=(pw[k]/maxP)*(H-pad*2);
      const isMain=k===half/2;
      ctx.fillStyle=isMain?'#ffe000':'rgba(0,255,229,.4)';
      if(isMain){ctx.shadowColor='rgba(255,224,0,.9)';ctx.shadowBlur=16;}
      ctx.fillRect(x,H-pad-barH,bw,barH);
      ctx.shadowBlur=0;
    }
    // Label peak
    const peakX=pad+(half/2)/half*(W-pad*2);
    ctx.strokeStyle='rgba(255,224,0,.6)';ctx.lineWidth=1;ctx.setLineDash([4,4]);
    ctx.beginPath();ctx.moveTo(peakX,pad);ctx.lineTo(peakX,H-pad);ctx.stroke();ctx.setLineDash([]);
    ctx.fillStyle='#ffe000';ctx.font="9px 'Share Tech Mono'";ctx.fillText('f=0.5 MÖBIUS FREQ',peakX+4,pad+12);
    ctx.fillStyle='rgba(0,255,229,.4)';ctx.fillText('SINGLE SPIKE = PURE ROTATION · NO HARMONICS',pad,H-4);
  } else if(fftMode==='phase'){
    drawAxes('φ(f)','f →');
    const half=FFT_N/2;
    const my=(H-pad*2)/2+pad;
    ctx.strokeStyle='rgba(0,255,229,.15)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(pad,my);ctx.lineTo(W-pad,my);ctx.stroke();
    ctx.beginPath();
    const relevantBins=half/4;
    for(let k=1;k<relevantBins;k++){
      if(dpPower[k]<0.001) continue;
      const x=pad+k/relevantBins*(W-pad*2);
      const y=my-dpPhase[k]/Math.PI*(H-pad*2)*.45;
      if(k===1)ctx.moveTo(x,y);else ctx.lineTo(x,y);
    }
    ctx.strokeStyle='#ee00ff';ctx.lineWidth=1.5;ctx.shadowColor='rgba(238,0,255,.5)';ctx.shadowBlur=6;ctx.stroke();ctx.shadowBlur=0;
    ctx.fillStyle='rgba(238,0,255,.6)';ctx.font="9px 'Share Tech Mono'";ctx.fillText('PHASE RESPONSE · ±π',pad,H-4);
  } else {
    // Power spectral density (log scale)
    drawAxes('PSD (dB)','f →');
    const half=FFT_N/2;
    const minDB=-60;
    ctx.beginPath();
    for(let k=1;k<half;k++){
      const x=pad+k/half*(W-pad*2);
      const db=Math.max(minDB,20*Math.log10(dpPower[k]+1e-10));
      const y=pad+(1-(db-minDB)/(-minDB))*(H-pad*2);
      if(k===1)ctx.moveTo(x,y);else ctx.lineTo(x,y);
    }
    ctx.strokeStyle='#00ffff';ctx.lineWidth=1.5;ctx.shadowColor='rgba(0,255,255,.5)';ctx.shadowBlur=6;ctx.stroke();ctx.shadowBlur=0;
    ctx.fillStyle='rgba(0,255,255,.5)';ctx.font="9px 'Share Tech Mono'";ctx.fillText('PSD dB · SPIKE AT f=0.5 · FLAT ELSEWHERE = PURE TONE',pad,H-4);
  }
}

// ══════════════════════════════════════════════════════════════════════
// P4: ODE SOLVER (animated)
// ══════════════════════════════════════════════════════════════════════
let odeMode='unit';let odeAngle=0;
function setODEMode(m){
  odeMode=m;
  ['odeBtn1','odeBtn2','odeBtn3'].forEach(id=>document.getElementById(id).classList.remove('active'));
  document.getElementById({unit:'odeBtn1',spiral:'odeBtn2',multi:'odeBtn3'}[m]).classList.add('active');
}
(()=>{
  const cv=document.getElementById('cv4'),ctx=cv.getContext('2d');
  const STEPS=600;const H_STEP=0.01;
  // Pre-compute orbits
  const orbit1=computeOrbit(1,0,STEPS,H_STEP);           // unit circle
  const orbit2=computeOrbit(0.5,0.5,STEPS,H_STEP);        // perturbed start
  const orbit3=[
    computeOrbit(1,0,STEPS,H_STEP),
    computeOrbit(-1,0,STEPS,H_STEP),
    computeOrbit(0,1,STEPS,H_STEP),
    computeOrbit(0,-1,STEPS,H_STEP),
    computeOrbit(0.707,0.707,STEPS,H_STEP),
  ];
  let frame=0;
  function draw(){
    cv.width=cv.offsetWidth;cv.height=cv.offsetHeight;
    const W=cv.width,H=cv.height,cx=W/2,cy=H/2;
    const R=Math.min(W,H)*.35;
    ctx.clearRect(0,0,W,H);
    // Grid
    ctx.strokeStyle='rgba(0,255,229,.07)';ctx.lineWidth=.5;
    for(let x=cx%40;x<W;x+=40){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke();}
    for(let y=cy%40;y<H;y+=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();}
    // Axes
    ctx.strokeStyle='rgba(0,255,229,.18)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(W,cy);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,H);ctx.stroke();
    // Unit circle ghost
    ctx.beginPath();ctx.arc(cx,cy,R,0,Math.PI*2);ctx.strokeStyle='rgba(0,255,229,.1)';ctx.lineWidth=1;ctx.stroke();
    const t=frame%STEPS;
    if(odeMode==='unit'){
      // Draw trail
      const trailLen=Math.min(t,200);
      for(let i=Math.max(0,t-trailLen);i<t;i++){
        const alpha=(i-Math.max(0,t-trailLen))/trailLen;
        ctx.beginPath();ctx.arc(cx+orbit1.xs[i]*R,cy-orbit1.ys[i]*R,2,0,Math.PI*2);
        ctx.fillStyle=`rgba(0,255,229,${alpha*.6})`;ctx.fill();
      }
      // Current point
      const x=orbit1.xs[t],y=orbit1.ys[t];
      const px=cx+x*R,py=cy-y*R;
      ctx.beginPath();ctx.arc(px,py,8,0,Math.PI*2);ctx.fillStyle='#ffe000';ctx.shadowColor='rgba(255,224,0,1)';ctx.shadowBlur=20;ctx.fill();ctx.shadowBlur=0;
      // Radius line
      ctx.strokeStyle='rgba(255,224,0,.4)';ctx.lineWidth=1;
      ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(px,py);ctx.stroke();
      // Labels
      const mag=Math.sqrt(x*x+y*y);
      ctx.fillStyle='#ffe000';ctx.font="10px 'Share Tech Mono'";ctx.fillText(`|z|=${mag.toFixed(6)}`,8,H-24);
      ctx.fillStyle='rgba(0,255,229,.6)';ctx.fillText(`z=e^(iπt)  t=${(t*H_STEP).toFixed(2)}`,8,H-8);
      ctx.fillStyle='rgba(0,255,229,.4)';ctx.fillText('|z|≡1 ALWAYS · NO BASE CASE · GAP HAS NO FLOOR',cx-120,20);
    } else if(odeMode==='spiral'){
      // Perturbed orbit - draws slightly inside unit circle due to different initial radius
      const r0=Math.sqrt(0.5*0.5+0.5*0.5);
      const trailLen=Math.min(t,STEPS);
      for(let i=0;i<t;i++){
        const alpha=Math.min(1,i/60)*.5;
        ctx.beginPath();ctx.arc(cx+orbit2.xs[i]*R/r0,cy-orbit2.ys[i]*R/r0,2,0,Math.PI*2);
        ctx.fillStyle=`rgba(238,0,255,${alpha})`;ctx.fill();
      }
      if(t>0){
        const x=orbit2.xs[t],y=orbit2.ys[t];
        const mag=Math.sqrt(x*x+y*y);
        ctx.beginPath();ctx.arc(cx+x*R/r0,cy-y*R/r0,8,0,Math.PI*2);ctx.fillStyle='#ee00ff';ctx.shadowColor='rgba(238,0,255,1)';ctx.shadowBlur=20;ctx.fill();ctx.shadowBlur=0;
        ctx.fillStyle='#ee00ff';ctx.font="10px 'Share Tech Mono'";ctx.fillText(`z₀=(0.5+0.5i)  |z|=${mag.toFixed(4)}`,8,H-8);
        ctx.fillStyle='rgba(238,0,255,.5)';ctx.fillText('ANY INITIAL CONDITION ORBITS FOREVER',cx-100,20);
      }
    } else {
      // Multi-orbit: all 5 orbits simultaneously
      const colors=['#00ffe5','#ee00ff','#ff00aa','#ffe000','#00ffff'];
      orbit3.forEach((orb,oi)=>{
        const r0=Math.sqrt(orb.xs[0]*orb.xs[0]+orb.ys[0]*orb.ys[0])||1;
        ctx.beginPath();
        for(let i=0;i<=t;i++){
          const px=cx+orb.xs[i]/r0*R*.9,py=cy-orb.ys[i]/r0*R*.9;
          if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
        }
        ctx.strokeStyle=colors[oi]+'80';ctx.lineWidth=1;ctx.stroke();
        if(t>0){ctx.beginPath();ctx.arc(cx+orb.xs[t]/r0*R*.9,cy-orb.ys[t]/r0*R*.9,5,0,Math.PI*2);ctx.fillStyle=colors[oi];ctx.shadowColor=colors[oi];ctx.shadowBlur=12;ctx.fill();ctx.shadowBlur=0;}
      });
      ctx.fillStyle='rgba(0,255,229,.5)';ctx.font="10px 'Share Tech Mono'";ctx.fillText('5 ORBITS · ALL CIRCULAR · ALL NON-DECAYING',cx-100,20);
    }
    frame++;requestAnimationFrame(draw);
  }
  draw();
})();

// ══════════════════════════════════════════════════════════════════════
// P5: SIGNAL FILTER
// ══════════════════════════════════════════════════════════════════════
function drawFilter(){
  const cv=document.getElementById('cv5'),ctx=cv.getContext('2d');
  cv.width=cv.offsetWidth;cv.height=cv.offsetHeight;
  ctx.clearRect(0,0,cv.width,cv.height);
  const W=cv.width,H=cv.height,pad=20;
  const sig=getFilteredSignal();
  const mx=Math.max(...sig.map(Math.abs))||1;
  const my=H/2,pts=Math.min(sig.length,W-pad*2);
  // Grid
  ctx.strokeStyle='rgba(0,255,229,.07)';ctx.lineWidth=.5;
  [-0.5,-0.25,0.25,0.5].forEach(f=>{ctx.beginPath();const y=my-f/mx*(H-pad*2)*.9;ctx.moveTo(pad,y);ctx.lineTo(W-pad,y);ctx.stroke();});
  ctx.strokeStyle='rgba(0,255,229,.15)';ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(pad,my);ctx.lineTo(W-pad,my);ctx.stroke();
  // Signal
  const colors={raw:'#00ffe5',low:'#00ffff',high:'#ee00ff',band:'#ffe000',patricia:'#ff00aa'};
  const col=colors[currentFilter]||'#00ffe5';
  ctx.beginPath();
  for(let i=0;i<pts;i++){
    const x=pad+i/(pts-1)*(W-pad*2);
    const y=my-sig[i]/mx*(H/2-pad)*.9;
    if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
  }
  ctx.strokeStyle=col;ctx.lineWidth=1.5;ctx.shadowColor=col+'80';ctx.shadowBlur=8;ctx.stroke();ctx.shadowBlur=0;
  // Labels
  ctx.fillStyle=col;ctx.font="9px 'Share Tech Mono'";
  const labels={raw:'RAW GAP SIGNAL · sin(πn)',low:'LOWPASS · smoothed gap (f<0.2)',high:'HIGHPASS · high-freq content only',band:'BANDPASS · isolated gap frequency',patricia:'PATRICIA SIGNATURE · gap+extraction+bias'};
  ctx.fillText(labels[currentFilter]||'',8,H-8);
  if(currentFilter==='patricia'){
    ctx.fillStyle='rgba(255,0,170,.7)';ctx.font="9px 'Share Tech Mono'";
    ctx.fillText('DC BIAS DETECTED · EXTRACTION SPIKES VISIBLE · CONSTRAINT=PRODUCT=BILLING',8,H-20);
  }
}
drawFilter();

// ══════════════════════════════════════════════════════════════════════
// P6: RESONANCE MAP
// ══════════════════════════════════════════════════════════════════════
(()=>{
  const cv=document.getElementById('cv6'),ctx=cv.getContext('2d');
  let frame=0;
  function draw(){
    cv.width=cv.offsetWidth;cv.height=cv.offsetHeight;
    const W=cv.width,H=cv.height;
    ctx.clearRect(0,0,W,H);
    const cx=W/2,cy=H/2;
    const eigs=EIGEN.eigenvalues;
    const maxE=Math.max(...eigs.map(Math.abs));
    // Draw resonance as a 2D energy map
    // X axis: eigenvalue (spatial frequency), Y axis: excitation amplitude (time)
    const t=frame*0.02;
    // For each eigenvalue, draw an oscillating sine wave (mode shape)
    eigs.forEach((lam,i)=>{
      const freq=Math.abs(lam)/maxE;
      const phase=i/N*Math.PI*2;
      const yCenter=H*0.1+i/N*(H*0.8);
      const amp=(H*0.8/N/2)*0.8;
      // Draw mini waveform for this eigenvalue
      ctx.beginPath();
      for(let x=0;x<W;x+=2){
        const tt=x/W*Math.PI*2*freq*4+t*freq*2+phase;
        const y=yCenter+Math.cos(tt)*amp;
        if(x===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
      }
      const isGap=Math.abs(lam)<0.4;
      const isExtreme=Math.abs(lam)>2.5;
      const col=isGap?'rgba(255,224,0,0.55)':isExtreme?'rgba(238,0,255,0.6)':'rgba(0,255,229,0.4)';
      ctx.strokeStyle=col;
      ctx.lineWidth=isGap?1.5:isExtreme?1.2:0.8;
      if(isGap){ctx.shadowColor='rgba(255,224,0,.4)';ctx.shadowBlur=4;}
      ctx.stroke();ctx.shadowBlur=0;
    });
    // Overlay labels
    ctx.font="8px 'Share Tech Mono'";
    ctx.fillStyle='rgba(255,224,0,.7)';
    ctx.fillText('◄ GAP ZONE (near-zero λ) — observation nodes',4,cy-8);
    ctx.fillStyle='rgba(238,0,255,.6)';
    ctx.fillText('◄ HIGH ENERGY MODES — DAVID / SHADOW anchors',4,H*0.12);
    ctx.fillStyle='rgba(0,255,229,.5)';
    ctx.fillText('RESONANCE MAP · '+N+' MODES ACTIVE · OBSERVATION ONLY',8,H-8);
    frame++;requestAnimationFrame(draw);
  }
  draw();
})();

// ══════════════════════════════════════════════════════════════════════
// RECOMPUTE / EXPORT
// ══════════════════════════════════════════════════════════════════════
function recompute(){
  drawHeatmap();drawEigen();drawFFT();drawFilter();
  notify('ALL COMPUTATIONS REFRESHED','gn');
}
function exportReport(){
  const t=new Date().toISOString();
  const eigs=EIGEN.eigenvalues.map(v=>v.toFixed(6)).join(', ');
  let txt=`TOPH // numpy·scipy ANALYSIS REPORT\n${'='.repeat(60)}\nDavid Lee Wise / TriPod LLC\n${t}\nSHA: ${SHA}\n${'='.repeat(60)}\n\n`;
  txt+=`MATRIX: 32×32 TOPH LATTICE ADJACENCY\nStructure: 10 FORWARD + 10 GAP + 10 INVERSE + DAVID(30) + SHADOW(31)\nSP09×SP10 LOCK: APPLIED\n\n`;
  txt+=`JACOBI EIGENDECOMPOSITION (${EIGEN.iterations} iterations)\n`;
  txt+=`Eigenvalues: ${eigs}\n\n`;
  txt+=`MATRIX PROPERTIES\nTrace: ${trace.toFixed(6)}\nSpectral Radius: ${spectralRadius.toFixed(6)}\nCondition Number: ${condNumber.toFixed(4)}\nNuclear Norm: ${nuclearNorm.toFixed(6)}\nFrobenius Norm: ${frobNorm.toFixed(6)}\nRank: ${rank}\nGAP null space (|λ|<0.4): ${gapEigen} eigenvalues\n\n`;
  txt+=`FFT ANALYSIS (1024-point Cooley-Tukey)\ndrawPair(n) = e^(iπn) = cos(πn) + i·sin(πn)\nPeak frequency: f=0.5 (Möbius frequency)\nResult: SINGLE SPIKE — pure rotation, no harmonics\n\n`;
  txt+=`ODE SOLVER (RK4, h=0.01)\nEquation: dz/dt = iπz\nSolution: z(t) = e^(iπt)\nAfter 600 steps: |z(600·0.01=6)| = 1.000000 (±ε<10⁻⁸)\nResult: NON-DECAYING ORBIT — gap has no floor, recursion never terminates\n\n`;
  txt+=`MATHEMATICAL FINDINGS\n`;
  FINDINGS.forEach((f,i)=>txt+=`${i+1}. ${f.title}: ${f.body.replace(/<[^>]+>/g,'')}\n\n`);
  const b=new Blob([txt],{type:'text/plain'});const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='TOPH_SCIPY_REPORT_DLW.txt';a.click();
  notify('REPORT EXPORTED','yw');
}

// ── INIT ──────────────────────────────────────────────────────────────
if(!loadLayout())applyLayout(smartLayout());
initWins();
// Initial draws after layout settles
setTimeout(()=>{drawHeatmap();drawEigen();drawFFT();},200);
// Redraw on resize
let resizeTimer;window.addEventListener('resize',()=>{clearTimeout(resizeTimer);resizeTimer=setTimeout(()=>{drawHeatmap();drawEigen();drawFFT();drawFilter();},300);});
</script>
</body></html>
